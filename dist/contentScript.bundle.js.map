{"version":3,"file":"contentScript.bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AENA;AACA;AACA;AACA;AACA","sources":["webpack://power-up_extension/./src/api/api-service.js","webpack://power-up_extension/./src/contentScript.js","webpack://power-up_extension/webpack/bootstrap","webpack://power-up_extension/webpack/runtime/define property getters","webpack://power-up_extension/webpack/runtime/hasOwnProperty shorthand","webpack://power-up_extension/webpack/runtime/make namespace object","webpack://power-up_extension/webpack/before-startup","webpack://power-up_extension/webpack/startup","webpack://power-up_extension/webpack/after-startup"],"sourcesContent":["export class APIService {\r\n    static async generateComment(postContent, posterName) {\r\n        try {\r\n            const settings = await chrome.storage.sync.get(['apiKey', 'defaultPrompt', 'aiModel', 'temperature', 'maxTokens', 'blacklist']);\r\n\r\n            if (!postContent || !posterName) {\r\n                throw new Error('Missing required content for comment generation.');\r\n            }\r\n\r\n            if (!settings.apiKey) {\r\n                throw new Error('API key not configured. Please go to extension options and configure your Google AI API key.');\r\n            }\r\n\r\n            const prompt = settings.defaultPrompt\r\n                ? settings.defaultPrompt\r\n                    .replace('{content}', postContent)\r\n                    .replace('{name}', posterName)\r\n                : `Generate a professional comment for LinkedIn post by ${posterName}: \"${postContent}\"`;\r\n\r\n            const apiBaseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/';\r\n            const model = 'gemini-pro';\r\n            const apiUrl = `${apiBaseUrl}${model}:generateContent`;\r\n            const apiKeyParam = `?key=${settings.apiKey}`;\r\n            const fullApiUrl = apiUrl + apiKeyParam;\r\n\r\n            console.log('Making API request to:', fullApiUrl);\r\n            console.log('Request body:', {\r\n                contents: [{\r\n                    parts: [{\r\n                        text: prompt\r\n                    }]\r\n                }],\r\n                generationConfig: {\r\n                    temperature: settings.temperature || 0.7,\r\n                    maxOutputTokens: settings.maxTokens || 150,\r\n                }\r\n            });\r\n\r\n            const response = await fetch(fullApiUrl, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JSON.stringify({\r\n                    contents: [{\r\n                        parts: [{\r\n                            text: prompt\r\n                        }]\r\n                    }],\r\n                    generationConfig: {\r\n                        temperature: settings.temperature || 0.7,\r\n                        maxOutputTokens: settings.maxTokens || 150,\r\n                    }\r\n                })\r\n            });\r\n\r\n            console.log('Response status:', response.status);\r\n            console.log('Response headers:', Object.fromEntries(response.headers.entries()));\r\n\r\n            if (!response.ok) {\r\n                const responseBody = await response.text();\r\n                let errorData;\r\n                try {\r\n                    errorData = JSON.parse(responseBody);\r\n                } catch (e) {\r\n                    errorData = { parseError: e.message, responseBody: responseBody };\r\n                }\r\n                console.error('API Error Details:', {\r\n                    status: response.status,\r\n                    statusText: response.statusText,\r\n                    headers: Object.fromEntries(response.headers.entries()),\r\n                    errorData: errorData,\r\n                    responseBody: responseBody\r\n                });\r\n                throw new Error(\r\n                    `API request failed with status ${response.status}. ${errorData.error?.message || 'Unknown error'}. Response body: ${responseBody}`\r\n                );\r\n            }\r\n\r\n            const data = await response.json();\r\n            console.log('API Response data:', data);\r\n            \r\n            if (data.candidates && data.candidates[0]?.content?.parts?.[0]?.text) {\r\n                let generatedText = data.candidates[0].content.parts[0].text.trim();\r\n\r\n                // Apply blacklist filtering if configured\r\n                if (settings.blacklist) {\r\n                    const blacklistWords = settings.blacklist.split('\\n')\r\n                        .map(word => word.trim())\r\n                        .filter(word => word);\r\n                    if (blacklistWords.length > 0) {\r\n                        const regex = new RegExp(blacklistWords.join('|'), 'gi');\r\n                        generatedText = generatedText.replace(regex, '***');\r\n                    }\r\n                }\r\n\r\n                return generatedText;\r\n            } else {\r\n                throw new Error('The AI service returned an unexpected response format. Please try again.');\r\n            }\r\n        } catch (error) {\r\n            console.error('Error generating comment:', error);\r\n            console.error('Error stack:', error.stack);\r\n            // Enhance error message for user display\r\n            const userMessage = error.message.includes('API key') \r\n                ? error.message \r\n                : `Failed to generate comment: ${error.message}`;\r\n            throw new Error(userMessage);\r\n        }\r\n    }\r\n}\r\n","import { APIService } from './api/api-service.js';\r\n\r\nif (window.linkedInEnhancerInitialized) {\r\n    console.log(\"LinkedIn Enhancer already initialized, skipping...\");\r\n} else {\r\n    window.linkedInEnhancerInitialized = true;\r\n\r\n    console.log(\"Content script loaded and running\");\r\n\r\n    // Debug configuration\r\n    const DEBUG = {\r\n        enabled: true,\r\n        logPostHTML: true,\r\n        logSelectors: true\r\n    };\r\n\r\n    function debugLog(...args) {\r\n        if (DEBUG.enabled) {\r\n            console.log(...args);\r\n        }\r\n    }\r\n\r\n    function debugError(...args) {\r\n        if (DEBUG.enabled) {\r\n            console.error(...args);\r\n        }\r\n    }\r\n\r\n    async function generateAIComment(postId, posts) {\r\n        try {\r\n            // Get the post data\r\n            const post = posts.find(p => p.index === parseInt(postId));\r\n            if (!post) {\r\n                throw new Error(\"Post not found\");\r\n            }\r\n\r\n            debugLog(\"Found post:\", post);\r\n\r\n            // Call API Service to generate comment\r\n            const apiResponse = await APIService.generateComment(post.postContent, post.posterName);\r\n\r\n            if (!apiResponse) {\r\n                throw new Error(\"API response is undefined\");\r\n            }\r\n\r\n            return {\r\n                comment: apiResponse,\r\n                debug: {\r\n                    prompt: post.postContent,\r\n                    timestamp: new Date().toISOString(),\r\n                    model: 'gemini-2.0-flash-exp'\r\n                }\r\n            };\r\n\r\n        } catch (error) {\r\n            debugError(\"Error generating AI comment:\", {\r\n                error: error,\r\n                message: error.message,\r\n                stack: error.stack,\r\n                timestamp: new Date().toISOString()\r\n            });\r\n            return {\r\n                error: error.message,\r\n                debug: {\r\n                    errorStack: error.stack,\r\n                    timestamp: new Date().toISOString()\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    // Store posts globally to access them during comment generation\r\n    let cachedPosts = [];\r\n\r\n    chrome.runtime.onMessage.addListener(\r\n        function(request, sender, sendResponse) {\r\n            debugLog(\"Content script received message:\", request);\r\n            \r\n            if (request.action === \"getPostContent\") {\r\n                try {\r\n                    debugLog(\"Getting LinkedIn posts...\");\r\n                    const postContent = getLinkedInPosts();\r\n                    cachedPosts = postContent; // Cache the posts\r\n                    debugLog(\"Retrieved posts:\", postContent);\r\n                    \r\n                    sendResponse({ \r\n                        posts: postContent,\r\n                        debug: {\r\n                            totalPostsFound: postContent.length,\r\n                            timestamp: new Date().toISOString()\r\n                        }\r\n                    });\r\n                } catch (error) {\r\n                    debugError(\"Error getting posts:\", error);\r\n                    sendResponse({ \r\n                        posts: [], \r\n                        error: error.message,\r\n                        debug: {\r\n                            errorStack: error.stack,\r\n                            timestamp: new Date().toISOString()\r\n                        }\r\n                    });\r\n                }\r\n            } else if (request.action === \"generateComment\") {\r\n                // Use async/await with generateAIComment\r\n                generateAIComment(request.postId, cachedPosts)\r\n                    .then(response => {\r\n                        debugLog(\"Generated comment response:\", response);\r\n                        sendResponse(response);\r\n                    })\r\n                    .catch(error => {\r\n                        debugError(\"Error in generateComment:\", error);\r\n                        sendResponse({\r\n                            error: error.message,\r\n                            debug: {\r\n                                errorStack: error.stack,\r\n                                timestamp: new Date().toISOString()\r\n                            }\r\n                        });\r\n                    });\r\n                return true; // Keep the message channel open for async response\r\n            }\r\n            return true; // Keep the message channel open\r\n        }\r\n    );\r\n\r\n    function getLinkedInPosts() {\r\n        debugLog(\"Starting to extract posts\");\r\n        const posts = [];\r\n        \r\n        // Updated selectors for modern LinkedIn feed\r\n        const postContainers = document.querySelectorAll([\r\n            'div.feed-shared-update-v2',\r\n            'div.occludable-update',\r\n            'div[data-urn]',\r\n            'div.feed-shared-update-v2__content',\r\n            'div.update-components-actor',\r\n            'div.feed-shared-actor'\r\n        ].join(', '));\r\n        \r\n        debugLog(`Found ${postContainers.length} potential post containers`);\r\n\r\n        if (postContainers.length === 0) {\r\n            debugError(\"No post containers found. DOM structure may have changed.\");\r\n            return [];\r\n        }\r\n\r\n        postContainers.forEach((postContainer, index) => {\r\n            try {\r\n                if (DEBUG.logPostHTML) {\r\n                    debugLog(`Post ${index + 1} HTML:`, postContainer.outerHTML);\r\n                }\r\n\r\n                const postData = extractPostData(postContainer, index);\r\n                \r\n                if (postData.isValid) {\r\n                    posts.push({\r\n                        posterName: postData.posterName,\r\n                        postContent: postData.postContent,\r\n                        timestamp: new Date().toISOString(),\r\n                        index: index\r\n                    });\r\n                }\r\n            } catch (error) {\r\n                debugError(`Error processing post ${index + 1}:`, error);\r\n            }\r\n        });\r\n\r\n        debugLog(`Successfully extracted ${posts.length} valid posts`);\r\n        return posts.filter(post => post.postContent && post.postContent !== \"Content not available\");\r\n    }\r\n\r\n    function extractPostData(postContainer, index) {\r\n        const nameSelectors = [\r\n            'span.update-components-actor__name',\r\n            'span.feed-shared-actor__name',\r\n            'span.update-components-actor__title',\r\n            'a.update-components-actor__meta-link',\r\n            'a[data-control-name=\"actor_container\"] span',\r\n            'div.update-components-actor__meta-link',\r\n            '.actor-name',\r\n            'div.feed-shared-actor__title span'\r\n        ];\r\n\r\n        const contentSelectors = [\r\n            'div.feed-shared-update-v2__description-wrapper',\r\n            'div.feed-shared-text-view',\r\n            'div.update-components-text',\r\n            'div.feed-shared-text',\r\n            'div.update-components-text__text-view',\r\n            'div.feed-shared-update-v2__commentary',\r\n            'span[dir=\"ltr\"]',\r\n            'div.feed-shared-inline-show-more-text'\r\n        ];\r\n\r\n        let posterName = findElementContent(postContainer, nameSelectors, 'name', index);\r\n        let postContent = findElementContent(postContainer, contentSelectors, 'content', index);\r\n\r\n        // Clean up the extracted text\r\n        if (postContent) {\r\n            postContent = cleanUpPostContent(postContent);\r\n            postContent = removeNameFromContent(postContent, posterName);\r\n        }\r\n\r\n        return {\r\n            posterName: posterName || \"Unknown User\",\r\n            postContent: postContent || \"Content not available\",\r\n            isValid: Boolean(posterName && postContent && \r\n                            postContent !== \"Content not available\")\r\n        };\r\n    }\r\n\r\n    function findElementContent(container, selectors, type, postIndex) {\r\n        for (let selector of selectors) {\r\n            try {\r\n                if (DEBUG.logSelectors) {\r\n                    debugLog(`Trying ${type} selector on post ${postIndex + 1}:`, selector);\r\n                }\r\n                \r\n                const element = container.querySelector(selector);\r\n                if (element) {\r\n                    const content = element.innerText || element.textContent;\r\n                    if (content && content.trim()) {\r\n                        debugLog(`Found ${type} using selector \"${selector}\":`, content.trim());\r\n                        return content.trim();\r\n                    }\r\n                }\r\n            } catch (error) {\r\n                debugError(`Error with selector \"${selector}\":`, error);\r\n            }\r\n        }\r\n        debugLog(`Could not find ${type} for post ${postIndex + 1}`);\r\n        return null;\r\n    }\r\n\r\n    function cleanUpPostContent(text) {\r\n        if (text) {\r\n            // Remove extra whitespace and line breaks\r\n            let cleanedText = text.replace(/\\s+/g, ' ').trim();\r\n            // Remove any leading or trailing newlines\r\n            cleanedText = cleanedText.replace(/^\\n+|\\n+$/g, '');\r\n            // Handle HTML entities and decode them\r\n            const tempElement = document.createElement('div');\r\n            tempElement.innerHTML = cleanedText;\r\n            cleanedText = tempElement.textContent || tempElement.innerText || \"\";\r\n            return cleanedText;\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    function removeNameFromContent(content, name) {\r\n        if (!content || !name) {\r\n            return content;\r\n        }\r\n\r\n        // Split name into parts to handle first/last name separately\r\n        const nameParts = name.split(/\\s+/);\r\n\r\n        // Create a regex that matches:\r\n        // 1. The exact full name\r\n        // 2. The name followed by \"shared\" or \"posted\"\r\n        // 3. The name at the start of the content\r\n        const patterns = [\r\n            `(${name.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')}\\\\s*)`,\r\n            `(${name.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')}\\\\s*(shared|posted|writes|commented|likes))`,\r\n            `^(${name.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')}\\\\s*)`\r\n        ];\r\n\r\n        let cleanContent = content;\r\n\r\n        // Apply each pattern\r\n        patterns.forEach(pattern => {\r\n            const regex = new RegExp(pattern, 'gi');\r\n            cleanContent = cleanContent.replace(regex, '');\r\n        });\r\n\r\n        // Clean up any resulting double spaces and trim\r\n        cleanContent = cleanContent.replace(/\\s+/g, ' ').trim();\r\n\r\n        return cleanContent;\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n__webpack_require__(\"./src/contentScript.js\");\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/api/api-service.js\");\n",""],"names":[],"sourceRoot":""}